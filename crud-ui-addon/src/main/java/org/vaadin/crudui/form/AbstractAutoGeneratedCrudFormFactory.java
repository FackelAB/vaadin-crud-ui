package org.vaadin.crudui.form;

import com.vaadin.flow.component.*;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.textfield.PasswordField;
import com.vaadin.flow.component.textfield.TextArea;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.data.binder.BeanValidationBinder;
import com.vaadin.flow.data.binder.Binder;
import com.vaadin.flow.data.converter.*;
import org.vaadin.crudui.crud.CrudOperation;
import org.vaadin.crudui.crud.CrudOperationException;
import org.vaadin.crudui.form.impl.field.provider.DefaultFieldProvider;
import org.vaadin.data.converter.StringToByteConverter;
import org.vaadin.data.converter.StringToCharacterConverter;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;

/**
 * @author Alejandro Duarte.
 */
public abstract class AbstractAutoGeneratedCrudFormFactory<T> extends AbstractCrudFormFactory<T> {

    protected Map<CrudOperation, String> buttonCaptions = new HashMap<>();
    protected Map<CrudOperation, Icon> buttonIcons = new HashMap<>();
    protected Map<CrudOperation, Set<String>> buttonStyleNames = new HashMap<>();
    protected Map<CrudOperation, String> buttonThemes = new HashMap<>();

    protected String cancelButtonCaption = "Cancel";
    protected String validationErrorMessage = "Please fix the errors and try again";

    protected Binder<T> binder;

    public AbstractAutoGeneratedCrudFormFactory(Class<T> beanType) {
        super(beanType);

        setButtonCaption(CrudOperation.READ, "Ok");
        setButtonCaption(CrudOperation.ADD, "Add");
        setButtonCaption(CrudOperation.UPDATE, "Update");
        setButtonCaption(CrudOperation.DELETE, "Yes, delete");

        setButtonIcon(CrudOperation.READ, null);
        setButtonIcon(CrudOperation.ADD, VaadinIcon.CHECK.create());
        setButtonIcon(CrudOperation.UPDATE, VaadinIcon.CHECK.create());
        setButtonIcon(CrudOperation.DELETE, VaadinIcon.TRASH.create());

        addButtonStyleName(CrudOperation.READ, null);
        addButtonTheme(CrudOperation.ADD, "primary");
        addButtonTheme(CrudOperation.UPDATE, "primary");
        addButtonTheme(CrudOperation.DELETE, "error");
    }

    public void setButtonCaption(CrudOperation operation, String caption) {
        buttonCaptions.put(operation, caption);
    }

    public void setButtonIcon(CrudOperation operation, Icon icon) {
        buttonIcons.put(operation, icon);
    }

    public void addButtonStyleName(CrudOperation operation, String styleName) {
        buttonStyleNames.putIfAbsent(operation, new HashSet<>());
        buttonStyleNames.get(operation).add(styleName);
    }

    public void addButtonTheme(CrudOperation operation, String theme) {
        buttonThemes.put(operation, theme);
    }

    public void setCancelButtonCaption(String cancelButtonCaption) {
        this.cancelButtonCaption = cancelButtonCaption;
    }

    public void setValidationErrorMessage(String validationErrorMessage) {
        this.validationErrorMessage = validationErrorMessage;
    }

    protected List<HasValueAndElement> buildFields(CrudOperation operation, T bean, boolean readOnly) {
        binder = buildBinder(operation, bean);
        ArrayList<HasValueAndElement> fields = new ArrayList<>();

        ArrayList<HasValueAndElement> fieldsWithCreationListeners = new ArrayList<>();
        ArrayList<FieldCreationListener> creationListeners = new ArrayList<>();

        Map<String, Property<T, ?>> propertiesMap = getConfiguration(operation).getPropertiesMap();
        propertiesMap.forEach((propertyName, property) -> {
            try {
                HasValueAndElement field = buildField(property);

                if (field != null) {
                    fields.add(field);
                    configureField(field, property, readOnly);
                    bindField(field, property, propertyName);

                    FieldCreationListener creationListener = property.getFieldCreationListener();
                    if (creationListener != null) {
                        fieldsWithCreationListeners.add(field);
                        creationListeners.add(creationListener);
                    }
                }

            } catch (Exception e) {
                throw new RuntimeException("Error creating Property for property " + beanType.getName() + "." + property,
                        e);
            }
        });

        fields.stream()
                .filter(field -> field.isEnabled() && !field.isReadOnly() && field instanceof Focusable)
                .map(field -> (Focusable) field)
                .findFirst()
                .ifPresent(Focusable::focus);

        binder.readBean(bean);

        for (int i = 0; i < fieldsWithCreationListeners.size(); i++) {
            creationListeners.get(i).fieldCreated(fieldsWithCreationListeners.get(i));
        }

        if (!fields.isEmpty() && !readOnly) {
            HasValue field = fields.get(0);
            if (field instanceof Focusable) {
                ((Focusable) field).focus();
            }
        }

        return fields;
    }

    protected HasValueAndElement buildField(Property<T, ?> property)
            throws InstantiationException, IllegalAccessException {
        HasValueAndElement<?, ?> field;
        FieldProvider<?, ?> provider = property.getFieldProvider();

        if (provider != null) {
            field = provider.buildField();
        } else {
            Class<? extends HasValueAndElement<?, ?>> fieldType = property.getFieldType();
            if (fieldType != null) {
                field = fieldType.newInstance();
            } else {
                field = new DefaultFieldProvider(property.getType()).buildField();
            }
        }

        return field;
    }

    private void configureField(HasValue field, Property<T, ?> property, boolean readOnly) {
        if (property.getFieldCaption() != null) {
            try {
                Method setLabelMethod = field.getClass().getMethod("setLabel", String.class);
                setLabelMethod.invoke(field, property.getFieldCaption());

            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException shouldNeverHappen) {
                throw new RuntimeException(shouldNeverHappen);
            }
        }

        if (field != null && field instanceof HasSize) {
            ((HasSize) field).setWidth("100%");
        }

        field.setReadOnly(readOnly);

        if (field instanceof HasEnabled) {
            ((HasEnabled) field).setEnabled(!property.isDisabled());
        }
    }

    protected void bindField(HasValue field, Property<T, ?> property, String propertyName) {
        Binder.BindingBuilder bindingBuilder = binder.forField(field);

        if (TextField.class.isAssignableFrom(field.getClass()) || PasswordField.class.isAssignableFrom(
                field.getClass()) || TextArea.class.isAssignableFrom(field.getClass())) {
            bindingBuilder = bindingBuilder.withNullRepresentation("");
        }

        if (Double.class.isAssignableFrom(property.getType()) || double.class.isAssignableFrom(property.getType())) {
            bindingBuilder = bindingBuilder.withConverter(new StringToDoubleConverter(null, "Must be a number"));

        } else if (Long.class.isAssignableFrom(property.getType()) || long.class.isAssignableFrom(property.getType())) {
            bindingBuilder = bindingBuilder.withConverter(new StringToLongConverter(null, "Must be a number"));

        } else if (BigDecimal.class.isAssignableFrom(property.getType())) {
            bindingBuilder = bindingBuilder.withConverter(new StringToBigDecimalConverter(null, "Must be a number"));

        } else if (BigInteger.class.isAssignableFrom(property.getType())) {
            bindingBuilder = bindingBuilder.withConverter(new StringToBigIntegerConverter(null, "Must be a number"));

        } else if (Integer.class.isAssignableFrom(property.getType()) || int.class.isAssignableFrom(
                property.getType())) {
            bindingBuilder = bindingBuilder.withConverter(new StringToIntegerConverter(null, "Must be a number"));

        } else if (Byte.class.isAssignableFrom(property.getType()) || byte.class.isAssignableFrom(property.getType())) {
            bindingBuilder = bindingBuilder.withConverter(new StringToByteConverter(null, "Must be a number"));

        } else if (Character.class.isAssignableFrom(property.getType()) || char.class.isAssignableFrom(
                property.getType())) {
            bindingBuilder = bindingBuilder.withConverter(new StringToCharacterConverter());

        } else if (Float.class.isAssignableFrom(property.getType()) || float.class.isAssignableFrom(
                property.getType())) {
            bindingBuilder = bindingBuilder.withConverter(new StringToFloatConverter(null, "Must be a number"));

        } else if (Date.class.isAssignableFrom(property.getType())) {
            bindingBuilder = bindingBuilder.withConverter(new LocalDateToDateConverter());
        }

        if (propertyName.startsWith(GENERATED_PROPERTY_NAME_PREFIX)) {
            // See: https://github.com/vaadin/flow/issues/4708
            bindingBuilder.bind(property.getGetter(), property.getSetter());
        } else {
            bindingBuilder.bind(propertyName);
        }
    }

    protected Binder<T> buildBinder(CrudOperation operation, T bean) {
        Binder<T> binder;

        if (getConfiguration(operation).isUseBeanValidation()) {
            binder = new BeanValidationBinder(beanType);
        } else {
            binder = new Binder(beanType);
        }

        return binder;
    }

    protected Button buildOperationButton(CrudOperation operation, T beanType,
            ComponentEventListener<ClickEvent<Button>> clickListener) {
        if (clickListener == null) {
            return null;
        }

        String caption = buttonCaptions.get(operation);
        Icon icon = buttonIcons.get(operation);
        Button button = icon != null ? new Button(caption, icon) : new Button(caption);
        if (buttonStyleNames.containsKey(operation)) {
            buttonStyleNames.get(operation).stream().filter(styleName -> styleName != null).forEach(
                    styleName -> button.addClassName(styleName));
        }
        if (buttonThemes.containsKey(operation)) {
            button.getElement().setAttribute("theme", buttonThemes.get(operation));
        }

        button.addClickListener(event -> {
            if (binder.writeBeanIfValid(beanType)) {
                try {
                    clickListener.onComponentEvent(event);
                } catch (Exception e) {
                    showError(operation, e);
                }
            } else {
                Notification.show(validationErrorMessage);
            }
        });
        return button;
    }

    @Override
    public void showError(CrudOperation operation, Exception e) {
        if (errorListener != null) {
            errorListener.accept(e);
        } else {
            Notification notification = new Notification(e.getMessage(), 5000);
            notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            notification.open();

            if (!CrudOperationException.class.isAssignableFrom(e.getClass())) {
                throw new RuntimeException("Error executing " + operation.name() + " operation", e);
            }
        }
    }

    protected Button buildCancelButton(ComponentEventListener<ClickEvent<Button>> clickListener) {
        if (clickListener == null) {
            return null;
        }

        return new Button(cancelButtonCaption, clickListener);
    }

    protected Component buildFooter(CrudOperation operation, T beanType,
            ComponentEventListener<ClickEvent<Button>> cancelButtonClickListener,
            ComponentEventListener<ClickEvent<Button>> operationButtonClickListener) {
        Button operationButton = buildOperationButton(operation, beanType, operationButtonClickListener);
        Button cancelButton = buildCancelButton(cancelButtonClickListener);

        HorizontalLayout footerLayout = new HorizontalLayout();
        footerLayout.setSizeUndefined();
        footerLayout.setSpacing(true);
        footerLayout.setPadding(false);

        if (cancelButton != null) {
            footerLayout.add(cancelButton);
        }

        if (operationButton != null) {
            footerLayout.add(operationButton);
        }

        return footerLayout;
    }

}
